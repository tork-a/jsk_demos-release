(load "package://drc_task_common/euslisp/lib/angle-vector-sequence.l")
(load "package://drc_task_common/euslisp/lib/plotlib.l")
(load "package://drc_task_common/euslisp/lib/table.l")

(defclass end-effector-evaluator
  :super propertied-object
  :slots (robot target-limb))

(defmethod end-effector-evaluator
  (:init (r limb)
    (setq robot r)
    (setq target-limb limb)
    )
  (:target-limb () target-limb)
  (:profile (avs &key (max-speed-factor 5.0) (save-full-log nil) (log-name nil) (dspeed-factor 1.0))
    (when (and save-full-log (null log-name))
      (error "You need to specify :log-name parameter if :save-full-log t~%"))
    (let ((speed-factor 1.0)
          (tbl (instance table :init '("speed-factor" "time" "e"))))
      (while (< speed-factor max-speed-factor)
        (format t "interpolating sequence...~%")
        (send avs :interpolate *robot* (send *robot* :reset-pose) speed-factor 0.01)
        (let* ((pos-table (send self :position-table avs))
               (vel-table (send self :velocity-table pos-table)))
          (when save-full-log
            (let* ((dirname (format nil "log_~A_~A" (send robot :name) log-name))
                   (posfilename (format nil "~A/ee_log_pos_~A.csv" dirname speed-factor))
                   (velfilename (format nil "~A/ee_log_vel_~A.csv" dirname speed-factor)))
              (unix:mkdir dirname)
              (send pos-table :write posfilename)
              (send vel-table :write velfilename)
              ))
          (let ((e (send self :evaluate pos-table vel-table)))
            (format t "speed-factor=~A, e=~A~%" speed-factor e)
            (send tbl :add (list speed-factor (- (car (last (send pos-table :get-column-value "time"))) 1.0)
                                 e)))
          (setq speed-factor (+ dspeed-factor speed-factor))))
      (when save-full-log
        (send tbl :write "~A_~A_ee.csv" (send robot :name) log-name))
      tbl))
  (:position-table (avs)
    (let ((interpolated-avs (send avs :interpolated-angle-vectors))
          (interpolated-times (send avs :interpolated-times)))
      (let ((interpolated-pos (mapcar #'(lambda (av)
                                          (send robot :angle-vector av)
                                          (send robot :fix-leg-to-coords (make-coords))
                                          ;;(send *irtviewer* :draw-objects)
                                          (send (send robot target-limb :end-coords :copy-worldcoords) :worldpos))
                                      interpolated-avs)))
        (let ((pos-table (instance table :init '("time" "x" "y" "z"))))
          ;; pos-table
          (dotimes (i (length interpolated-times))
            (send pos-table :add (list (elt interpolated-times i)
                                       (elt (elt interpolated-pos i) 0)
                                       (elt (elt interpolated-pos i) 1)
                                       (elt (elt interpolated-pos i) 2)))
            )
          pos-table))))
  (:velocity-table (pos-table)
    (let ((interpolated-pos (mapcar #'float-vector
                                    (send pos-table :get-column-value "x")
                                    (send pos-table :get-column-value "y")
                                    (send pos-table :get-column-value "z")))
          (interpolated-times (send pos-table :get-column-value "time")))
      (let* ((interpolated-vel (mapcar #'(lambda (p0 p1 tm0 tm1)
                                           (scale (/ 1.0 (- tm1 tm0)) (v- p1 p0)))
                                       (butlast interpolated-pos)
                                       (cdr interpolated-pos)
                                       (butlast interpolated-times)
                                       (cdr interpolated-times)))
             (interpolated-vel-norm (mapcar #'norm interpolated-vel)))
        (let ((vel-table (instance table :init '("time" "vx" "vy" "vz" "v"))))
          ;; vel-table
          (dotimes (i (length interpolated-vel))
            (send vel-table :add (list (elt (cdr interpolated-times) i)
                                       (elt (elt interpolated-vel i) 0)
                                       (elt (elt interpolated-vel i) 1)
                                       (elt (elt interpolated-vel i) 2)
                                       (elt interpolated-vel-norm i)))
            )
          vel-table))))
  (:evaluate (pos-table vel-table &key (max-velocity 1200))
    (let* ((interpolated-vel-norm (send vel-table :get-column-value "v"))
           (interpolated-times (send vel-table :get-column-value "time"))
           (fulltime (car (last interpolated-times)))
           (dt (/ fulltime (length interpolated-times))))
      (let ((expected-value (/ (apply #'+
                                      (mapcar #'(lambda (v) (* 1.0 (/ v max-velocity)))
                                              interpolated-vel-norm))
                               fulltime (length interpolated-times))))
        (- 1 (min 1.0 expected-value)))))
  )

(defun merge-ee-zmp-table (ee-table zmp-table)
  (format t "ee-table:  ~A~%" (send ee-table :data-num))
  (format t "zmp-table: ~A~%" (send zmp-table :data-num))
  (when (= (send ee-table :data-num) (send zmp-table :data-num))
    (let ((tbl (instance table :init '("time" "speed-factor" "q" "q_zmp" "q_ee"))))
      (send ee-table :sort-by "time")
      (send zmp-table :sort-by "time")
      (dotimes (i (length (send ee-table :data)))
        (let ((ee-data (elt (send ee-table :data) i))
              (zmp-data (elt (send zmp-table :data) i)))
          (multiple-value-bind
           (ee-speed-factor ee-time ee-e) (send ee-table :get-columns-values '("speed-factor" "time" "e") ee-data)
           (multiple-value-bind
            (zmp-speed-factor zmp-time zmp-e) (send zmp-table :get-columns-values '("speed-factor" "time" "q") zmp-data)
            (unless (= ee-speed-factor zmp-speed-factor)
              (error "speed-factor is not same"))
            (send tbl :add (list zmp-time ee-speed-factor (* ee-e zmp-e) zmp-e ee-e))
            ))
          )
        )
      tbl)))

;; normalize zmp csv
(defun normalize-zmp-table (orig-table)
  (let ((tbl (instance table :init '("time" "speed-factor" "e" "q" "max-zmp-distance" "min-zmp-distance"))))
    (let* ((all-e (send orig-table :get-column-value "e"))
           (min-e (apply #'min all-e))
           (max-e (apply #'max all-e)))
      (dolist (d (send orig-table :data))
        (multiple-value-bind
         (time speed-factor e max-zmp-distance min-zmp-distance)
         (send orig-table :get-columns-values '("time" "speed-factor" "e" "max-zmp-distance" "min-zmp-distance") d)
         (send tbl :add (list time speed-factor e (normalize-value e max-e min-e) max-zmp-distance min-zmp-distance))
         ))
      tbl)))


;; normalize zmp_ee csv
(defun normalize-execution-table (orig-table)
  (let ((tbl (instance table :init (send orig-table :column))))
    (let* ((all-q (send orig-table :get-column-value "q"))
           (min-q (apply #'min all-q))
           (max-q (apply #'max all-q)))
      (dolist (d (send orig-table :data))
        (multiple-value-bind
         (time speed-factor q e_zmp e_ee)
         (send orig-table :get-columns-values '("time" "speed-factor" "q" "q_zmp" "q_ee") d)
         (send tbl :add (list time speed-factor (normalize-value q max-q min-q) e_zmp e_ee))
         ))
      tbl)))
